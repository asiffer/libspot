import argparse
import os
import sys

import numpy as np
import scipy.stats as ss

#
# TEMPLATES
#

template_data = """
double const {name}[] = {{
{data}}};
"""

template_result = """{{
.gamma = {gamma},
.sigma = {sigma},
.llhood = {llhood},
.data = {data},
.size = {size},
.name = {name},
}}""".replace(
    "\n", " "
)

template_target = """
struct Result {{
    char const *name;
    double gamma;
    double sigma;
    double llhood;
    unsigned long size;
    double const *data;
}};

struct Result results[] = {{
{data}
}};

// number of results
unsigned long const N = sizeof(results) / sizeof(struct Result);
// total number of data
unsigned long const n = {n};
// tail level
double const level = {level};
// number of excesses
long const Nt = n - (unsigned long)(level * (double)n);

// tmp data storage
double tmp_storage[{Nt}]; // Nt
"""


def format_data(distribution_name: str, distribution_data: np.ndarray) -> str:
    cols = 6
    rows = len(distribution_data) // cols
    stream = ""
    j = 0
    for r in range(rows):
        i = cols * r
        j = i + cols
        stream += (
            "\t"
            + ", ".join(f"{x:.8f}" for x in distribution_data[i:j])
            + ",\n"
        )

    stream += (
        "\t" + ", ".join(f"{x:.8f}" for x in distribution_data[j:]) + ",\n"
    )
    return template_data.format(name=distribution_name, data=stream)


if __name__ == "__main__":
    wd = os.path.abspath(os.path.dirname(__file__))

    parser = argparse.ArgumentParser(os.path.basename(__file__))
    parser.add_argument(
        "-o",
        "--output",
        help="where to print result",
        type=str,
        default=os.path.join(wd, "test_tail_fit.h"),
    )
    parser.add_argument(
        "-s",
        "--size",
        type=int,
        default=200000,
        help="number of data to generate",
    )
    parser.add_argument(
        "-l",
        "--level",
        type=float,
        default=0.995,
        help="probability related to the excess quantile (number of excesses: (1-level) * size)",
    )
    parser.add_argument(
        "-f",
        "--force",
        action="store_true",
        help="force output file overwriting",
    )
    args = parser.parse_args()

    # parameters
    file = args.output
    size: int = args.size
    level: float = args.level
    Nt = int((1.0 - level) * size)

    if not args.force and os.path.exists(file):
        answer = input(f"The file '{file}' already exists, overwrite? [yN] ")
        if answer.lower().strip() != "y":
            sys.exit(0)

    # distributions
    dist = {
        "exponential": np.random.standard_exponential(size=size),
        "uniform": np.random.uniform(size=size),
        "pareto": np.random.pareto(a=3, size=size),
        "lognormal": np.random.lognormal(mean=0, sigma=2, size=size),
    }

    mle = dict.fromkeys(dist.keys())

    data = []
    results = []
    for name, X in dist.items():
        t = np.sort(X)[size - Nt - 1]
        # excesses
        Y = X[X > t] - t

        shape, _, scale = ss.genpareto.fit(Y, floc=0.0, method="MLE")
        nnl = ss.genpareto.nnlf((shape, 0.0, scale), Y)

        # mle[name] = (shape, scale, -nnl)
        result = template_result.format(
            gamma=shape,
            sigma=scale,
            llhood=-nnl,
            data=name,
            size=len(Y),
            name=f'"{name}"',
        )
        results.append("\t" + result)
        data.append(format_data(name, Y))

    with open(file, "w", encoding="utf-8") as w:
        w.write(f"/* FILE GENERATED BY {parser.prog}. DO NOT EDIT. */\n")
        w.write("\n".join(data))
        w.write(
            template_target.format(
                data=",\n".join(results),
                n=size,
                level=level,
                Nt=Nt,
            )
        )

{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"libspot is a C++ library for anomaly detection in streaming data. The library uses Extreme Value Theory to perform probabilistic thresholding and is able to process more one million data a second on the average man's laptop. More precisely, libspot implements the SPOT algorithm . You can interact with the library either directly of through python bindings. Finally, a pure Go implementation also exist. As an example, the latter powers the Netspot Intrusion Detection System .","title":"Home"},{"location":"about/","text":"This library is an extension of research work previously published at KDD'17 conference. If libspot contributes to a project that leads to a scientific publication, please acknowledge this fact by citing the publication: Cite Siffer, A., Fouque, P. A., Termier, A., & Largouet, C. (2017, August). Anomaly Detection in Streams with Extreme Value Theory. In Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining (pp. 1067-1075). ACM. Here is the BibTeX record: @inproceedings { siffer2017anomaly, title= { Anomaly detection in streams with extreme value theory } , author= { Siffer, Alban and Fouque, Pierre-Alain and Termier, Alexandre and Largouet, Christine } , booktitle= { Proceedings of the 23rd ACM SIGKDD International Conference on Knowledge Discovery and Data Mining } , pages= { 1067--1075 } , year= { 2017 } }","title":"About"},{"location":"cpp/","text":"C++ Introduction libspot is the original C++ library. You can use it as-is of through python3 bindings . libspot implements the core algorithm SPOT which detects anomalies. Installing Git The code is hosted on github, so you can clone the repository git clone https://github.com/asiffer/libspot.git cd libspot && make sudo make install Ubuntu For Ubuntu users, the following personal package archive (ppa) can be added to you system: sudo add-apt-repository ppa:asiffer/libspot sudo apt-get update Then you can easily install the libspot package (and the libspot-dev package if you want the headers): sudo apt install libspot libspot-dev Debian-like distributions As the packaging is made on launchpad, they are specific to Ubuntu. However, the .deb files can easily be added to other debian-like systems. In /etc/apt/sources.list : ... deb http://ppa.launchpad.net/asiffer/libspot/ubuntu bionic main Then you can add the public key to your system and download the package: $ curl https://keyserver.ubuntu.com/pks/lookup \\? op \\= get \\& search \\= 0x76F580E5B58944D9 | sudo apt-key add - $ sudo apt update $ sudo apt install libspot libspot-dev Construct a Spot object Here is the full constructor of the Spot object: Spot ( double q , int n_init , double level , bool up , bool down , bool alert , bool bounded , int max_excess ); The main parameter is q . It defines the probability of an abnormal event. For example, if q = 0.001 , it means that the algorithm will consider events with a probability lower than q as abnormal. The parameters n_init and level are involved in the calibration step of the algorithm. n_init is the number of data required to calibrate and level is the proportion of these initial data not involved in the tail distribution fit. For example, let us use n_init = 1000 and level = 0.99 . The algorithm will drop the 990 lowest data and will keep the 10 highest to make a first fit. Warning In practice, the user must ensure that n_init * (1 - level) > 10 to have enough data for the fit (at least 10). Furthermore, the level must be high enough to reduce the bias of the algorithm. We may advice to have the level as close to 1 as possible. The booleans up and down define whether the algorithm computes upper/lower thresholds or not. The boolean alert = true enables alert triggering. If alert = false , it means that all the data (even those out of the bounds) will be taken into account. The boolean bounded = true enables the memory bounding. The bound is given by max_excess which is the maximum number of data stored to perform the tail fit. Warning If the memory is not bounded, the algorithm will store more and more data to perform the tail fit. However, the computation time will cause more problems than the memory growth because the tail fit complexity depends on this number of stored data. Other constructors libspot provides other constructors. For instance rather than specifying n_init (the number of data to calibrate), the user can provide an initial batch of data init_data . This batch will directly be used to perform the calibration. Spot ( double q , vector < double > init_data , double level , bool up , bool down , bool alert , bool bounded , int max_excess ); Finally, shorter constructors can also be used: Spot ( double q = 1e-3 , int n_init = 1000 ); Spot ( double q , vector < double > init_data ); The default values of the parameters are the following: q = 1e-3 ; n_init = 1000 ; level = 0.99 ; up = true ; down = true ; alert = true ; bounded = true ; max_excess = 200 ; Run Spot Once a Spot object is created you can feed it with data through the step method. int Spot . step ( double x ) According to the state of the algorithm or the detected event, this method returns an enum item SPOTEVENT:: (corresponding to an integer). enum item integer meaning NORMAL 0 Normal data ALERT_UP 1 Abnormal data (too high) ALERT_DOWN -1 Abnormal data (too low) EXCESS_UP 2 Excess (update the up model) EXCESS_DOWN -2 Excess (update the down model) INIT_BATCH 3 Data for initial batch CALIBRATION 4 Calibration step Example Here we give an example where Spot is applied on a Gaussian white noise of 10000 values. // main.cpp #include \"spot.h\" #include <random> #include <iostream> #include <algorithm> #include <vector> #include <math.h> using namespace std ; vector < double > gaussian_white_noise ( double mu , double sigma , int N ) { vector < double > v ( N ); random_device rd ; default_random_engine gen ( rd ()); normal_distribution < double > gaussian ( mu , sigma ); for ( int i = 0 ; i < N ; i ++ ) { v [ i ] = gaussian ( gen ); } return v ; } int main ( int argc , const char * argv []) { int N = 10000 ; vector < double > data = gaussian_white_noise ( 0 , 1 , N ); int nb_up_alarm = 0 ; int nb_down_alarm = 0 ; Spot S ; int output ; for ( auto & x : data ) { output = S . step ( x ); if ( output == SPOTVEVENT :: ALERT_UP ) { nb_up_alarm ++ ; } if ( output == SPOTVEVENT :: ALERT_DOWN ) { nb_down_alarm ++ ; } } cout << \"#Up Alerts: \" << nb_up_alarm << endl ; cout << \"#Down Alerts: \" << nb_down_alarm << endl ; return 0 ; } You can compile it with g++ and the C++11 standard: $ g++ -std = c++11 -Wall main.cpp -lspot","title":"C++"},{"location":"cpp/#c","text":"","title":"C++"},{"location":"cpp/#introduction","text":"libspot is the original C++ library. You can use it as-is of through python3 bindings . libspot implements the core algorithm SPOT which detects anomalies.","title":"Introduction"},{"location":"cpp/#installing","text":"","title":"Installing"},{"location":"cpp/#git","text":"The code is hosted on github, so you can clone the repository git clone https://github.com/asiffer/libspot.git cd libspot && make sudo make install","title":"Git"},{"location":"cpp/#ubuntu","text":"For Ubuntu users, the following personal package archive (ppa) can be added to you system: sudo add-apt-repository ppa:asiffer/libspot sudo apt-get update Then you can easily install the libspot package (and the libspot-dev package if you want the headers): sudo apt install libspot libspot-dev","title":"Ubuntu"},{"location":"cpp/#debian-like-distributions","text":"As the packaging is made on launchpad, they are specific to Ubuntu. However, the .deb files can easily be added to other debian-like systems. In /etc/apt/sources.list : ... deb http://ppa.launchpad.net/asiffer/libspot/ubuntu bionic main Then you can add the public key to your system and download the package: $ curl https://keyserver.ubuntu.com/pks/lookup \\? op \\= get \\& search \\= 0x76F580E5B58944D9 | sudo apt-key add - $ sudo apt update $ sudo apt install libspot libspot-dev","title":"Debian-like distributions"},{"location":"cpp/#construct-a-spot-object","text":"Here is the full constructor of the Spot object: Spot ( double q , int n_init , double level , bool up , bool down , bool alert , bool bounded , int max_excess ); The main parameter is q . It defines the probability of an abnormal event. For example, if q = 0.001 , it means that the algorithm will consider events with a probability lower than q as abnormal. The parameters n_init and level are involved in the calibration step of the algorithm. n_init is the number of data required to calibrate and level is the proportion of these initial data not involved in the tail distribution fit. For example, let us use n_init = 1000 and level = 0.99 . The algorithm will drop the 990 lowest data and will keep the 10 highest to make a first fit. Warning In practice, the user must ensure that n_init * (1 - level) > 10 to have enough data for the fit (at least 10). Furthermore, the level must be high enough to reduce the bias of the algorithm. We may advice to have the level as close to 1 as possible. The booleans up and down define whether the algorithm computes upper/lower thresholds or not. The boolean alert = true enables alert triggering. If alert = false , it means that all the data (even those out of the bounds) will be taken into account. The boolean bounded = true enables the memory bounding. The bound is given by max_excess which is the maximum number of data stored to perform the tail fit. Warning If the memory is not bounded, the algorithm will store more and more data to perform the tail fit. However, the computation time will cause more problems than the memory growth because the tail fit complexity depends on this number of stored data.","title":"Construct a Spot object"},{"location":"cpp/#other-constructors","text":"libspot provides other constructors. For instance rather than specifying n_init (the number of data to calibrate), the user can provide an initial batch of data init_data . This batch will directly be used to perform the calibration. Spot ( double q , vector < double > init_data , double level , bool up , bool down , bool alert , bool bounded , int max_excess ); Finally, shorter constructors can also be used: Spot ( double q = 1e-3 , int n_init = 1000 ); Spot ( double q , vector < double > init_data ); The default values of the parameters are the following: q = 1e-3 ; n_init = 1000 ; level = 0.99 ; up = true ; down = true ; alert = true ; bounded = true ; max_excess = 200 ;","title":"Other constructors"},{"location":"cpp/#run-spot","text":"Once a Spot object is created you can feed it with data through the step method. int Spot . step ( double x ) According to the state of the algorithm or the detected event, this method returns an enum item SPOTEVENT:: (corresponding to an integer). enum item integer meaning NORMAL 0 Normal data ALERT_UP 1 Abnormal data (too high) ALERT_DOWN -1 Abnormal data (too low) EXCESS_UP 2 Excess (update the up model) EXCESS_DOWN -2 Excess (update the down model) INIT_BATCH 3 Data for initial batch CALIBRATION 4 Calibration step","title":"Run Spot"},{"location":"cpp/#example","text":"Here we give an example where Spot is applied on a Gaussian white noise of 10000 values. // main.cpp #include \"spot.h\" #include <random> #include <iostream> #include <algorithm> #include <vector> #include <math.h> using namespace std ; vector < double > gaussian_white_noise ( double mu , double sigma , int N ) { vector < double > v ( N ); random_device rd ; default_random_engine gen ( rd ()); normal_distribution < double > gaussian ( mu , sigma ); for ( int i = 0 ; i < N ; i ++ ) { v [ i ] = gaussian ( gen ); } return v ; } int main ( int argc , const char * argv []) { int N = 10000 ; vector < double > data = gaussian_white_noise ( 0 , 1 , N ); int nb_up_alarm = 0 ; int nb_down_alarm = 0 ; Spot S ; int output ; for ( auto & x : data ) { output = S . step ( x ); if ( output == SPOTVEVENT :: ALERT_UP ) { nb_up_alarm ++ ; } if ( output == SPOTVEVENT :: ALERT_DOWN ) { nb_down_alarm ++ ; } } cout << \"#Up Alerts: \" << nb_up_alarm << endl ; cout << \"#Down Alerts: \" << nb_down_alarm << endl ; return 0 ; } You can compile it with g++ and the C++11 standard: $ g++ -std = c++11 -Wall main.cpp -lspot","title":"Example"},{"location":"download/","text":"Getting libspot Git Ubuntu Debian-like distributions Linux (Snap) Python Go Getting libspot Git The code is available on github. You can either clone the repository $ git clone https://github.com/asiffer/libspot.git or download the last version archive here . Ubuntu For Ubuntu users, the following personal package archive (ppa) can be added to you system: $ sudo add-apt-repository ppa:asiffer/libspot $ sudo apt-get update Then you can easily install the libspot package (and the libspot-dev package if you want the headers): $ sudo apt install libspot libspot-dev Debian-like distributions As the packaging is made on launchpad, they are specific to Ubuntu. However, the .deb files can easily be added to other debian-like systems. In /etc/apt/sources.list : ... deb http://ppa.launchpad.net/asiffer/libspot/ubuntu bionic main Then you can add the public key to your system and download the package: $ curl https://keyserver.ubuntu.com/pks/lookup \\? op \\= get \\& search \\= 0x76F580E5B58944D9 | sudo apt-key add - $ sudo apt update $ sudo apt install libspot libspot-dev Linux (Snap) I have recently discovered Snap which claims to be a universal app store for linux . You only need to install snap on your linux system and then: sudo snap install libspot I also give you the fancy button: Python The python3 bindings are also available on github or through the same ppa: $ sudo apt install python3-libspot You can also download these bindings through the pip package manager $ pip3 install pylibspot Unlike `apt` which checks the dependencies, you need to previously install the `libspot` library if you download the bindings through `pip`. Golang libspot has also been re-implemented in Go . You can get it through: $ go get github.com/asiffer/gospot","title":"Download"},{"location":"download/#getting-libspot","text":"","title":"Getting libspot"},{"location":"download/#git","text":"The code is available on github. You can either clone the repository $ git clone https://github.com/asiffer/libspot.git or download the last version archive here .","title":"Git"},{"location":"download/#ubuntu","text":"For Ubuntu users, the following personal package archive (ppa) can be added to you system: $ sudo add-apt-repository ppa:asiffer/libspot $ sudo apt-get update Then you can easily install the libspot package (and the libspot-dev package if you want the headers): $ sudo apt install libspot libspot-dev","title":"Ubuntu"},{"location":"download/#debian-like-distributions","text":"As the packaging is made on launchpad, they are specific to Ubuntu. However, the .deb files can easily be added to other debian-like systems. In /etc/apt/sources.list : ... deb http://ppa.launchpad.net/asiffer/libspot/ubuntu bionic main Then you can add the public key to your system and download the package: $ curl https://keyserver.ubuntu.com/pks/lookup \\? op \\= get \\& search \\= 0x76F580E5B58944D9 | sudo apt-key add - $ sudo apt update $ sudo apt install libspot libspot-dev","title":"Debian-like distributions"},{"location":"download/#linux-snap","text":"I have recently discovered Snap which claims to be a universal app store for linux . You only need to install snap on your linux system and then: sudo snap install libspot I also give you the fancy button:","title":"Linux (Snap)"},{"location":"download/#python","text":"The python3 bindings are also available on github or through the same ppa: $ sudo apt install python3-libspot You can also download these bindings through the pip package manager $ pip3 install pylibspot Unlike `apt` which checks the dependencies, you need to previously install the `libspot` library if you download the bindings through `pip`.","title":"Python"},{"location":"download/#golang","text":"libspot has also been re-implemented in Go . You can get it through: $ go get github.com/asiffer/gospot","title":"Golang"},{"location":"go/","text":"Golang libspot has also been re-implemented in Go . You can get it through: go get -u github.com/asiffer/gospot","title":"Go"},{"location":"go/#golang","text":"libspot has also been re-implemented in Go . You can get it through: go get -u github.com/asiffer/gospot","title":"Golang"},{"location":"python/","text":"Python Yes, python3 bindings exist. Thanks to the powerful built-in package ctypes we make the use of libspot through python possible. Tou can download these bindings through pip : pip3 install pylibspot Warning You need to install the C++ library first to use these python interface Introduction The Spot constructor is very straightforward. We reuse the full constructor of the C++ library but without the positional argument constraint: Spot ( q = 1e-4 , n_init = 2000 , level = 0.99 , up = True , down = True , alert = True , bounded = True , max_excess = 200 ) Warning Be careful, the default values of the python constructor may not be the same as in the native library. Quick example Basically, you need to init an instance of the algorithm and then feed some data with the .step() method. import pylibspot as ps import numpy as np N = 200000 X = np . random . normal ( 0 , 1 , N ) s = ps . Spot ( q = 1e-4 , up = True , down = False , n_init = 2000 ) for x in X : if s . step ( x ) == 1 : # check the return code print ( f \"Anomaly found: { x } > { s . get_upper_threshold () } \" ) Another example Here we give an application of the SPOT algorithm. The script and the data are available on the github repository python3-libspot (in the 'example' folder). In this example we monitor the ratio of SYN packets in a network traffic capture. The original .pcap files are provided by the MAWI platform. Here we use aggregated data (measures over time slots) from two consecutive capture days (August 17 and 18, 2012). import pyspot as ps # name of the python3 package import pandas as pd import matplotlib.pyplot as plt # loading data MAWI_17 = pd . read_csv ( \"mawi_170812_50_50.csv\" , index_col = [ 0 ]) MAWI_18 = pd . read_csv ( \"mawi_180812_50_50.csv\" , index_col = [ 0 ]) # we keep only the ratio of SYN packets rSYN_17 = MAWI_17 [ 'rSYN' ] rSYN_18 = MAWI_18 [ 'rSYN' ] # initialization of the Spot object q = 5e-4 n_init = 2000 spot = ps . Spot ( q , n_init , up = True , down = False ) ## CALIBRATION for r in rSYN_17 [ - n_init :]: spot . step ( r ) ## ANOMALY DETECTION # we init some structure to log what flags the algorithm up_threshold = [ 0.0 ] * len ( rSYN_18 ) anomalies_x = [] anomalies_y = [] i = 0 for r in rSYN_18 : event = spot . step ( r ) if event == 1 : # anomaly case anomalies_x . append ( i ) anomalies_y . append ( r ) up_threshold [ i ] = spot . get_upper_threshold () i = i + 1 # Plotting stuff plt . plot ( rSYN_18 , lw = 2 , color = \"#1B4B5A\" ) f1 , = plt . plot ( up_threshold , ls = 'dashed' , color = \"#AE81FF\" , lw = 2 ) f2 = plt . scatter ( anomalies_x , anomalies_y , color = \"#F55449\" ) plt . legend ([ f1 , f2 ], [ 'Threshold' , 'Anomalies' ]) plt . xticks ( range ( 0 , 18001 , 3000 ), range ( 0 , 901 , 150 )) # we change the ticks to make it corresponds to the true time : 1 it = 50 ms plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Ratio of SYN packets' ) The output is given below. In this case, we can notice that the algorithm builds a relevant threshold able to flag abnormal peaks.","title":"Python"},{"location":"python/#python","text":"Yes, python3 bindings exist. Thanks to the powerful built-in package ctypes we make the use of libspot through python possible. Tou can download these bindings through pip : pip3 install pylibspot Warning You need to install the C++ library first to use these python interface","title":"Python"},{"location":"python/#introduction","text":"The Spot constructor is very straightforward. We reuse the full constructor of the C++ library but without the positional argument constraint: Spot ( q = 1e-4 , n_init = 2000 , level = 0.99 , up = True , down = True , alert = True , bounded = True , max_excess = 200 ) Warning Be careful, the default values of the python constructor may not be the same as in the native library.","title":"Introduction"},{"location":"python/#quick-example","text":"Basically, you need to init an instance of the algorithm and then feed some data with the .step() method. import pylibspot as ps import numpy as np N = 200000 X = np . random . normal ( 0 , 1 , N ) s = ps . Spot ( q = 1e-4 , up = True , down = False , n_init = 2000 ) for x in X : if s . step ( x ) == 1 : # check the return code print ( f \"Anomaly found: { x } > { s . get_upper_threshold () } \" )","title":"Quick example"},{"location":"python/#another-example","text":"Here we give an application of the SPOT algorithm. The script and the data are available on the github repository python3-libspot (in the 'example' folder). In this example we monitor the ratio of SYN packets in a network traffic capture. The original .pcap files are provided by the MAWI platform. Here we use aggregated data (measures over time slots) from two consecutive capture days (August 17 and 18, 2012). import pyspot as ps # name of the python3 package import pandas as pd import matplotlib.pyplot as plt # loading data MAWI_17 = pd . read_csv ( \"mawi_170812_50_50.csv\" , index_col = [ 0 ]) MAWI_18 = pd . read_csv ( \"mawi_180812_50_50.csv\" , index_col = [ 0 ]) # we keep only the ratio of SYN packets rSYN_17 = MAWI_17 [ 'rSYN' ] rSYN_18 = MAWI_18 [ 'rSYN' ] # initialization of the Spot object q = 5e-4 n_init = 2000 spot = ps . Spot ( q , n_init , up = True , down = False ) ## CALIBRATION for r in rSYN_17 [ - n_init :]: spot . step ( r ) ## ANOMALY DETECTION # we init some structure to log what flags the algorithm up_threshold = [ 0.0 ] * len ( rSYN_18 ) anomalies_x = [] anomalies_y = [] i = 0 for r in rSYN_18 : event = spot . step ( r ) if event == 1 : # anomaly case anomalies_x . append ( i ) anomalies_y . append ( r ) up_threshold [ i ] = spot . get_upper_threshold () i = i + 1 # Plotting stuff plt . plot ( rSYN_18 , lw = 2 , color = \"#1B4B5A\" ) f1 , = plt . plot ( up_threshold , ls = 'dashed' , color = \"#AE81FF\" , lw = 2 ) f2 = plt . scatter ( anomalies_x , anomalies_y , color = \"#F55449\" ) plt . legend ([ f1 , f2 ], [ 'Threshold' , 'Anomalies' ]) plt . xticks ( range ( 0 , 18001 , 3000 ), range ( 0 , 901 , 150 )) # we change the ticks to make it corresponds to the true time : 1 it = 50 ms plt . xlabel ( 'Time (s)' ) plt . ylabel ( 'Ratio of SYN packets' ) The output is given below. In this case, we can notice that the algorithm builds a relevant threshold able to flag abnormal peaks.","title":"Another example"}]}